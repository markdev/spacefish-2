<!DOCTYPE html>
<head>
    <style>
        canvas#canvas { background-color: #000; }
        #results li.pass { color: green; }
        #results li.fail { color: red; }
    </style>
  <!--  <script src="jquery-1.9.0.min.js"></script> -->
    <script src="jquery-1.10.2.js"></script>
    <script src="myFunctions.js"></script>
</head>
<body>

<canvas id="canvas" height="700" width="1200">Joo cannot see me!</canvas>

<ul id="results"></ul>

<script>
var Game = function () {
    this.canvas = document.getElementById("canvas");
    this.ctx = canvas.getContext("2d");
    this.bufferCanvas = document.createElement("canvas");
    this.bufferCanvasCtx = this.bufferCanvas.getContext("2d");
    this.bufferCanvasCtx.canvas.width = this.ctx.canvas.width;
    this.bufferCanvasCtx.canvas.height = this.ctx.canvas.height;

    this.intervals = [];

    this.gameLoop = {};

    this.time = 0;
    this.startTime = 0;

    this.currentLevel = "";
    this.events = [];
    this.score = 0;
    this.lives = 3;
    this.img = {};
    this.imgArray = ["AGHeads", "bigBloater", "bigBloaterA", "bigBloaterB", "crabCakesA", "crabCakesB", "darkBack", "explosionSprite", "homingFishA", "homingFishB", "orbbouncy", "orbdrill", "orbhellfire", "orbhoming", "orblaser", "orbmega", "orbshock", "planetview", "seasky", "sinusoidSwimmerA", "sinusoidSwimmerB", "spaceShip", "spaceShipA", "spaceShipB", "spaceShipMegaA", "spaceShipMegaB", "spaceShipShield", "spaceShipShieldA", "spaceShipShieldB", "speedyBlueA", "speedyBlueB", "spitFireBulletA", "spitFireBulletB", "spitFireFishA", "spitFireFishB", "splitFishBigA", "splitFishBigB", "splitFishSmallA", "splitFishSmallB", "startScreen", "theSea", "trippyeyeballs", "youLose", "youWin"];
};

Game.prototype = {
    loadImage : function loadImage(i) {     // naming this function makes it accessible only for self-reference; it is not globally accessible
        i = (typeof i !== 'undefined') ? i : 0;
        var img = new Image();
        img.src = 'images/' + game.imgArray[i] + '.png';
        img.onload = function(e) {
            window['game']['img'][game.imgArray[i]] = img;
            i++;
            if (i < game.imgArray.length) {
                loadImage(i);   // see, that was painless
            } else {
                // <!-- Move this into a script later
                window.spaceFishData = {
                    splashScreen : {
                        "type" : "basicSplashScreen",   // Integrate this
                        "background" : "startScreen",
                        "flashText" : { x: 500, y: 600, content: "Click to continue", font: "20pt Arial", color: "white"},
                        "events" : [
                            {"event" : "mousedown", "action" : function() {game.loadGameLoop("levelOne");}}
                        ]
                    },
                    levelOne : {
                        "type" : "sideScrollLevel",
                        "background" : "theSea",
                        "timer" : 5,
               //         "opponents" : ["Bill", "Sam", "Luciano", "Homer", "Darren", "Frank", "CrabCakes"]
                        "opponents": ["Bill", "Frank", "Sam", "Luciano"],
                        "win" : "levelTwo"
                    },
                    levelTwo : {
                        "type" : "sideScrollLevel",
                        "background" : "planetview",
                        "timer" : 5,
                        //         "opponents" : ["Bill", "Sam", "Luciano", "Homer", "Darren", "Frank", "CrabCakes"]
                        "opponents": ["Sam", "Darren"],
                        "win" : "secondScreen"
                    },
                    secondScreen : {
                        "type" : "basicSplashScreen",
                        "background" : "youWin",
                        "flashText" : { x: 500, y: 600, content: "Click to start over", font: "20pt Arial", color: "white"},
                        "events" : [
                            {"event" : "mousedown", "action" : function() {game.loadGameLoop("splashScreen");}}
                        ]
                    },
                    loseScreen : {
                        "type" : "basicSplashScreen",
                        "background" : "youLose",
                        "flashText" : { x: 500, y: 600, content: "Click to start over", font: "20pt Arial", color: "white"},
                        "events" : [
                            {"event" : "mousedown", "action" : function() {game.initialize();}}
                        ]
                    }
                }
                // --> move this into a script later
                game.initialize();
            }
        };
    },

    initialize : function() {
        game.lives = 5;
        game.score = 0;
        game.loadGameLoop("splashScreen");
    },

    removeListeners : function(listener) {
        game.canvas.removeEventListener(listener.event, listener.action);
    },

    addListeners : function(listener) {
        game.canvas.addEventListener(listener.event, listener.action);
    },

    loadGameLoop : function(gameScreen) {
        // start gameLoop
        game.gameLoop.cancelAnimationFrame = true;
        var gameScreen = (typeof gameScreen === "undefined")? "splashScreen" : gameScreen;
        game.currentLevel = gameScreen;
        var d = new Date();
        var n = String(d.getTime());
        game.startTime = n.substring(10);
        this.gameLoop = new GameLoop(spaceFishData[gameScreen]);

        // remove all the event handlers and empty this.events
        if (this.events.length > 0) {
            for (var i=0, len=this.events.length-1; i<=len; i++) {
                game.removeListeners(this.events[0]);
                this.events.shift();
            }
        }
        // load this.events and add handlers
        if (this.events.length == 0) {
            // load from game data
            if (spaceFishData[gameScreen].hasOwnProperty('events')) {       // TODO: see if these two if/for loops can be refactored
                for (var i=0; i<=spaceFishData[gameScreen]['events'].length-1; i++) {
                    this.events[this.events.length] = spaceFishData[gameScreen]['events'][i];
                    game.addListeners(this.events[this.events.length-1]);
                }
            }
            // load from level function
            if (window[spaceFishData[gameScreen].type].hasOwnProperty('events')) {
                for (var i=0; i<=window[spaceFishData[gameScreen].type].events.length-1; i++) {
                    this.events[this.events.length] = window[spaceFishData[gameScreen].type]['events'][i];
                    game.addListeners(this.events[this.events.length-1]);
                }
            }
        }

        // assign members to this.gameLoop from levelData
        for (var key in spaceFishData[gameScreen]) {
            this.gameLoop[key] = spaceFishData[gameScreen][key];
        }
        // extend an invoked function with an object
        extend(this.gameLoop, window[spaceFishData[gameScreen].type]);

        // clear all the existing intervals
        if (typeof game.intervals[0] !== 'undefined') {
            for (var i=0; i<=game.intervals.length-1; i++) {
                clearInterval(game.intervals[i]);
            }
        }

        // start this shit
        this.gameLoop.initialize();

        // run the animation loop
        this.gameLoop.animate();
    }
}


var GameLoop = function(level) {
    var self = this;
    this.cancelAnimationFrame = false;
    this.initialize = function() {};
    this.clearScreen = function() {};
    this.update = function() {};
    this.render = function() {};
    this.drawbuffer = function() {
        game.ctx.drawImage(game.bufferCanvas, 0, 0, game.bufferCanvas.width, game.bufferCanvas.height);
    };
    this.animate = function(time) {
        game.time = time;
        self.clearScreen();
        self.update();
        self.render();
        self.drawbuffer();
        if (self.cancelAnimationFrame == false) {
            requestAnimationFrame(self.animate);    // TODO: accommodate mozRequestAnimationFrame, etc
        }
    };
}

/*
 *    GameLoop Level Types
 *
 */

var basicSplashScreen = {
  /*  "initialize" : (function () {
        game.lives = 3;
        game.score = 0;
    } ()),  */
    "clearScreen" : function() {
        game.bufferCanvasCtx.drawImage(window['game']['img'][this.background], 0, 0);
    },
    "update" : function() {
        var d = new Date();
        var n = String(d.getTime());
        if (n.substring(10) > 500) {
            game.bufferCanvasCtx.font = this.flashText.font;
            game.bufferCanvasCtx.fillStyle = this.flashText.color;
            game.bufferCanvasCtx.fillText(this.flashText.content, this.flashText.x, this.flashText.y);
        }
    }
}

var sideScrollLevel = {
    "initialize" : function() {
        game.startTime = +new Date();
        game.elapsedTime = undefined;
        game.levelTime = window.spaceFishData[game.currentLevel].timer * 1000;

        game.levelShift = 0; // TODO: fix this gayness

        game.playerArray = [];
        game.playerProjectileArray = [];
        game.opponentProjectileArray = [];
        game.opponentArray = [];
        game.itemArray = [];
        game.effectArray = [];
        game.displayArray = [];
        game.objectArrays = [
            { "name" : "playerArray", "collidesWith" : "opponentArray", "action" : function(a, b, i, j) {if (a.x + a.w > b.x && a.x < b.x + b.w && a.y + a.h > b.y && a.y < b.y + b.h) { a.getHit(i); game.opponentArray.splice(j,1);}}},
            { "name" : "playerProjectileArray", "collidesWith" : "opponentArray", "action" : function (a, b, i, j) {if (a.x + a.radius > b.x && a.x < b.x + b.w && a.y + a.radius > b.y && a.y < b.y + b.h) {b.getHit(j); game.playerProjectileArray.splice(i,1);}}},
            { "name" : "opponentProjectileArray", "collidesWith" : "playerArray", "action" : function (a, b, i, j) {if (a.x + a.radius > b.x && a.x < b.x + b.w && a.y + a.radius > b.y && a.y < b.y + b.h) {b.getHit(j);  game.opponentProjectileArray.splice(i,1);}}},
            { "name" : "opponentArray"},
            { "name" : "itemArray", "collidesWith" : "playerArray", "action" : function(a, b, i, j) {if (a.x + a.w > b.x && a.x < b.x + b.w && a.y + a.h > b.y && a.y < b.y + b.h) {game.itemArray[i].action(); game.itemArray.splice(i,1);}}},
            { "name" : "effectArray"},
            { "name" : "displayArray"}
        ];

        // Create the player
        game.playerArray[game.playerArray.length] = new sideScrollLevel.Player({ x : 0, y : canvas.height/2, w : 120, h : 60 });

        // Create the main display
 //       game.displayArray[game.displayArray.length] = new sideScrollLevel.Display(sideScrollLevel.DisplayData.topBar);
        game.displayArray[game.displayArray.length] = new sideScrollLevel.Display({"level" : game.currentLevel, "score" : game.score, "time" : 30, "lives" : game.lives,
            "update" : function() {},
            "render" : function() {
                game.bufferCanvasCtx.font = "20pt Arial";
                game.bufferCanvasCtx.fillStyle = "white";
                var ymargin = 30;
                game.bufferCanvasCtx.fillText("Level: " + game.currentLevel, 20, ymargin);
                game.bufferCanvasCtx.fillText("Score: " + game.score, 300, ymargin);
                game.bufferCanvasCtx.fillText("Time: " + game.currentTime.substr(0,2), 500, ymargin);
                game.bufferCanvasCtx.fillText("Lives: " + game.lives, 800, ymargin);
            }
        });

        // Generate Opponents
        game.intervals[game.intervals.length] = setInterval(function() {    // Generate opponents at random
            game.opponentArray[game.opponentArray.length] = new sideScrollLevel.Opponent(sideScrollLevel['OpponentData'][spaceFishData[game.currentLevel]['opponents'][Math.floor(Math.random() * spaceFishData[game.currentLevel]['opponents'].length)]]);
        }, 1000);
    },
    "clearScreen" : function() {
        game.bufferCanvasCtx.fillStyle = "black";
        game.bufferCanvasCtx.fillRect(0, 0, game.bufferCanvasCtx.canvas.width, game.bufferCanvasCtx.canvas.height);

        game.bufferCanvasCtx.drawImage(game['img'][window.spaceFishData[game.currentLevel].background], game.levelShift, 0);
    },
    "update" : function() {
        // shift background
        game.levelShift -= .2;

        // update game time
        game.currentTime = String(game.levelTime - (+new Date() - game.startTime));
        while (game.currentTime.length !== 5) {
            var zero = "0";
            game.currentTime = zero.concat(game.currentTime);
        }
        if (Number(game.currentTime) < 0) game.loadGameLoop(window.spaceFishData[game.currentLevel].win);

        // update object arrays
        for (var k=0; k<=game.objectArrays.length-1; k++) {
            if (typeof game[game.objectArrays[k].name][0] !== "undefined") {
                for (var i=0; i<=game[game.objectArrays[k].name].length-1; i++) {
                    game[game.objectArrays[k].name][i].update();

                    // DetectRemoval will switch the terminate value to true, which wipes it out below.
                    game[game.objectArrays[k].name][i].detectRemoval();

                    // Collision detection
                    var a = game[game.objectArrays[k].name][i];
                    if (typeof game.objectArrays[k].collidesWith !== "undefined") {
                        for (var j=0; j<=game[game.objectArrays[k].collidesWith].length-1; j++) {
                            var b = game[game.objectArrays[k].collidesWith][j];
                            game.objectArrays[k].action(a, b, i, j);
                        }
                    }
                }

                // Remove blasts from projectileArray when they fly off the screen
                for (var i=0; i<=game[game.objectArrays[k].name].length-1; i++) {
                    if (game[game.objectArrays[k].name][i].terminate == true) {
                        game[game.objectArrays[k].name].splice(i,1);
                    }
                }
            }
        }
    },
    "render" : function() {
        for (var k=0; k<=game.objectArrays.length-1; k++) {
            if (typeof game[game.objectArrays[k].name] !== "undefined") {
                for (var i=0; i<=game[game.objectArrays[k].name].length-1; i++) {
                    game[game.objectArrays[k].name][i].render(game[game.objectArrays[k].name][i]);
                }
            }
        }

        var modeHeight = 0;
        if (game.playerArray[0].weapon.name  !== "peaShooter") {
            game.bufferCanvasCtx.fillStyle = game.playerArray[0].weapon.color;
            var startX = (game.bufferCanvas.width/2) - ((game.playerArray[0].weapon.endTime - game.playerArray[0].weapon.currentTime) / (game.playerArray[0].weapon.endTime - game.playerArray[0].weapon.startTime)) * (game.bufferCanvas.width/2);
            var endX = ((game.playerArray[0].weapon.endTime - game.playerArray[0].weapon.currentTime) / (game.playerArray[0].weapon.endTime - game.playerArray[0].weapon.startTime)) * (game.bufferCanvas.width/2) * 2;
            game.bufferCanvasCtx.fillRect(startX, game.bufferCanvas.height-50, endX, 50);

            game.bufferCanvasCtx.font = "20pt Arial";
            game.bufferCanvasCtx.fillStyle = "white";
            game.bufferCanvasCtx.fillText(game.playerArray[0].weapon.title, game.bufferCanvas.width/2 - 50, game.bufferCanvas.height - 15);
            modeHeight += 50;
        }

        if (game.playerArray[0].mode.name  !== "normal") {
            game.bufferCanvasCtx.fillStyle = game.playerArray[0].mode.color;
            var startX = (game.bufferCanvas.width/2) - ((game.playerArray[0].mode.endTime - game.playerArray[0].mode.currentTime) / (game.playerArray[0].mode.endTime - game.playerArray[0].mode.startTime)) * (game.bufferCanvas.width/2);
            var endX = ((game.playerArray[0].mode.endTime - game.playerArray[0].mode.currentTime) / (game.playerArray[0].mode.endTime - game.playerArray[0].mode.startTime)) * (game.bufferCanvas.width/2) * 2;
            game.bufferCanvasCtx.fillRect(startX, game.bufferCanvas.height-(50+modeHeight), endX, 50);

            game.bufferCanvasCtx.font = "20pt Arial";
            game.bufferCanvasCtx.fillStyle = "white";
            game.bufferCanvasCtx.fillText(game.playerArray[0].mode.title, game.bufferCanvas.width/2 - 50, game.bufferCanvas.height - (15+modeHeight));
        }
    },
    "events" : [
        {"event" : "mousedown", "action" : function() {
            sideScrollLevel['WeaponData'][game.playerArray[0].weapon.name]["fire"]();
        }},
        {"event" : "mousemove", "action" : function(e) {
            if (typeof game.playerArray[0] !== "undefined") {
                game.playerArray[0].y = e.pageY;
            }
        }}
    ],

    /*
     *    Game Object Prototypes
     *
     */



    "GameObject" : { "terminate" : false, "name" : "", "x" : 0, "y" : 0, "velx" : 0, "vely" : 0, "w" : 30, "h" : 15,
                     "update" : function () {this.x += this.velx; this.y += this.vely;},
                     "detectRemoval" : function () {if (this.x < -(this.w) || this.x > canvas.width) {this.terminate = true;}},
                     "render" : function (updateObject) {
                         game.bufferCanvasCtx.drawImage(game['img'][updateObject.img], updateObject.x, updateObject.y, updateObject.w, updateObject.h);}
                    },

    "GameObjectInit" : function (self, argData) {
        for (var key in sideScrollLevel.GameObject) {if (!self.hasOwnProperty(key)) self[key] = sideScrollLevel.GameObject[key];}
        for (var key in argData) {self[key] = argData[key];}
    },

    "Player" : function (argData) {
        var self = this;
        this.init = sideScrollLevel.GameObjectInit(self, argData);

        this.name = "player";

        this.health = 1;
        this.img = "spaceShipA";
        this.weapon = { // TODO change title parameter in data file (name) to title
            "name" : "peaShooter",
            "color" : "white",
            "title" : "Pea Shooter",
            "startTime" : 0,
            "endTime" : 0,
            "currentTime" : 0
        };
        this.mode = {
            "name" : "normal",
            "color" : "white",
            "title" : "Normal",
            "startTime" : 0,
            "endTime" : 0,
            "currentTime" : 0
        };
        this.update = function () {
            if (this.weapon.name !== "peaShooter") {
                this.weapon.currentTime = +new Date();
                if (this.weapon.currentTime > this.weapon.endTime) this.changeWeapon("peaShooter");
            }
            if (this.mode.name !== "normal") {
                this.mode.currentTime = +new Date();
                if (this.mode.currentTime > this.mode.endTime) this.changeMode("normal");
            }
        };
        this.getHit = function () {         //TODO: create a more robust, dynamic way of involving items
            if (self.mode.name == "mega") {
                self.changeMode('normal');
            } else if (self.mode.name == "drill") {
                // nothing happens!  //TODO: add effect?
            } else if (self.mode.name == "normal") {
                self.health -= 1;
                self.die();
            }
        };
        this.die = function () {
            game.lives -= 1;
            var levelToLoad = game.lives > 0 ? game.currentLevel : "loseScreen";
            game.loadGameLoop(levelToLoad);
        };
        this.changeWeapon = function(weapon, duration, color, title) {
            this.weapon.name = weapon;
            this.weapon.startTime = +new Date();
            this.weapon.endTime = this.weapon.startTime + (duration * 1000);
            this.weapon.color = color;
            this.weapon.title = title;
        };
        this.changeMode = function(mode) {
            var modes = {
                "normal" : {"mode" : "normal", "h" : 60, "w" : 120, "color" : "white", "health" : 1, "img" : "spaceShipA"},
                "mega" : {"mode" : "mega", "h" : 80, "w" : 120,  "color" : "green", "duration" : 2, "health" : 2, "img" : "spaceShipMegaA"},
                "drill" : {"mode" : "drill", "h" : 60, "w" : 145,  "color" : "orange", "duration" : 2, "health" : 1, "img" : "spaceShipShieldA"}
            };
            for (var key in modes[mode]) {
                if (modes[mode].hasOwnProperty(key)) {
                    if (key === "mode") {
                        self.mode.name = modes[mode][key];      // TODO: make polymorphic?  Maybe?
                    } else {
                        self[key] = modes[mode][key];
                    }
                }
            }
            if (mode !== "normal") {
                self.mode.startTime = +new Date();
                self.mode.endTime = self.mode.startTime + (modes[mode].duration * 1000);
                self.mode.color = modes[mode].color;
                self.mode.title = mode;
            }
        };
    },

    "Blast" : function (argData) {
        var self = this;
        this.init = sideScrollLevel.GameObjectInit(self, argData);
        this.source = typeof argData.source !== "undefined" ? argData.source : "player";
        this.x = typeof argData.x !== "undefined" ? argData.x : game.playerArray[0].w;
        this.y = typeof argData.y !== "undefined" ? argData.y : game.playerArray[0].y + game.playerArray[0].h/2;
        this.radius = typeof argData.radius !== "undefined" ? argData.radius : 0;       // TODO: add radius?
        this.color = typeof argData.color !== "undefined" ? argData.color : "white";
        this.detectRemoval = typeof argData.detectRemoval !== "undefined" ? argData.detectRemoval : function() {
            if (this.x > canvas.width || this.x < this.radius) {
                this.terminate = true;
            }
        };
        this.render = typeof argData.render !== "undefined" ? argData.render : function (updateObject) {
            game.bufferCanvasCtx.fillStyle = updateObject.color;
            game.bufferCanvasCtx.beginPath();
            game.bufferCanvasCtx.arc(updateObject.x, updateObject.y, updateObject.radius, 0, 2 * Math.PI);
            game.bufferCanvasCtx.fill();
        };
    },

    "Effect" : function(argData) {
        var self = this;
        this.init = sideScrollLevel.GameObjectInit(self, argData);
        this.sx = typeof argData.sx !== "undefined" ? argData.sx: 0;    // TODO: do I even need to declare any of these defaults?
        this.sy = typeof argData.sy !== "undefined" ? argData.sy: 0;
        this.opacity = typeof argData.opacity !== "undefined" ? argData.opacity: 0;
        this.text = typeof argData.text !== "undefined" ? argData.text : "";
    },

    "Display" : function(argData) {
        var self = this;
        this.init = sideScrollLevel.GameObjectInit(self, argData);
        this.text = typeof argData.text !== "undefined" ? argData.text : "";
    },

    "Opponent" : function (argData) {   // TODO: add items to opponent directly
        var self = this;
        this.init = sideScrollLevel.GameObjectInit(self, argData);
        this.score = typeof argData.score !== 'undefined' ? argData.score : 0;
        this.x = typeof argData.x !== 'undefined' ? argData.x : canvas.width;
        this.y = typeof argData.y !== 'undefined' ? argData.y : Math.random() * (canvas.height - this.h);
        this.detectRemoval = typeof argData.detectRemoval !== "undefined" ? argData.detectRemoval : function() {
            if (this.x < -(this.w)) {
                this.terminate = true;
            }
        };
        this.getHit = typeof argData.getHit !== 'undefined' ? argData.getHit : function(i) {
            // Generate item by default
            var argData = sideScrollLevel['ItemData'][sideScrollLevel['OpponentData'][self.name]["item"]];
            argData.x = self.x;
            argData.y = self.y + self.h/2;
            // Draw the score
            game.score += self.score;
            game.effectArray[game.effectArray.length] = new sideScrollLevel.Effect({"x" : self.x + self.w/2, "y" : self.y, "opacity" : 1, "text" : self.score, "update" : function() {this.y -= 2; this.opacity -= .02; if (this.opacity <= 0) {this.terminate = true;}}, "render" : function() {game.bufferCanvasCtx.font = "20pt Arial"; game.bufferCanvasCtx.fillStyle = "rgba(255,255,255," + this.opacity + ")"; game.bufferCanvasCtx.fillText(this.text, this.x, this.y);}});
            self.explode();
            game.itemArray[game.itemArray.length] = new sideScrollLevel.Item(argData);
            game.opponentArray.splice(i,1);
        };
        this.explode = function () {
            // Draw the explosion // TODO: create functions for explosions that pass in the object being blown up as a parameter.
            game.effectArray[game.effectArray.length] = new sideScrollLevel.Effect({"x" : self.x, "y" : self.y, "img" : "explosionSprite", "update" : function() {this.sx += 100; if (this.sx >= 600) {this.sx = 0; this.sy += 100;} if (this.sy > 600) {this.terminate = true;}}, "render" : function() {game.bufferCanvasCtx.drawImage(game['img'][this.img], this.sx, this.sy, 100, 100, this.x, this.y, 200, 200)}});
        };
    },

    "Item" : function(argData) {  // TODO: make this dynamic so that it is called by the opponent
        var self = this;
        this.init = sideScrollLevel.GameObjectInit(self, argData);
        this.w = 40; // TODO: change this to a radius maybe
        this.h = 40;
        this.velx = -4;
    },

    /*
     *    Game Object Data
     *
     */
    "OpponentData" : {
        "Bill" : { "name" : "Bill", "score" : 100, "w" : 300, "h" : 150, "velx" : 15, "img" : "bigBloaterA", "item" : "mega", "update" : function() {this.x -= this.velx;}},
        "Sam" : { "name" : "Sam", "score" : 200, "w" : 150, "h" : 75, "velx" : 20, "img" : "speedyBlueA", "item" : "dualLaser", "update" : function() {this.x -= this.velx;}},
        "Luciano" : { "name" : "Luciano", "score" : 300, "w" : 200, "h" : 300, "velx" : 25, "img" : "sinusoidSwimmerA", "item" : "shockWave", "update" : function() {this.x -= this.velx; var sin = Math.sin(this.x * 2.5) * 80; this.y += sin;}},
        "Homer" : { "name" : "Homer", "score" : 400, "w" : 230, "h" : 115, "velx" : 35, "img" : "homingFishA", "item" : "homingMissile", "update" : function() {this.x -= this.velx; this.y += ((this.y + this.h/2) > game.playerArray[0].y)? -10 : 10;}},
        "Darren" : { "name" : "Darren", "score" : 500, "w" : 250, "h" : 250, "velx" : 15, "img" : "splitFishBigA", "item" : "dualLaser", "update" : function() {this.x -= this.velx;}, "getHit" : function(i) {
            game.opponentArray[i].explode(); for (var k=-5; k<=5; k+=5) {
            var dylanData = sideScrollLevel['OpponentData']['Dylan']; dylanData.x = game.opponentArray[i].x; dylanData.y = game.opponentArray[i].y; dylanData.vely = k;
            game.opponentArray[game.opponentArray.length] = new sideScrollLevel.Opponent(dylanData);
        }
            game.opponentArray.splice(i,1);}},
        "Dylan" : { "name" : "Dylan", "score" : 500, "w" : 125, "h" : 75, "velx" : 25, "img" : "splitFishSmallA", "item" : "bouncyBalls", "update" : function() {this.x -= this.velx; this.y -= this.vely;}},
        "Frank" : { "name" : "Frank", "score" : 600,  "w" : 300, "h" : 150, "velx" : 15, "img" : "spitFireFishA", "item" : "drill", "update" : function() {this.x -= this.velx;  if (this.x >700 && this.x < 720) {game.opponentProjectileArray[game.opponentProjectileArray.length] = new sideScrollLevel.Blast({"name" : "Heroin", "source" : "opponent", "x" : this.x, "y" : this.y + this.h/2, "velx" : -20, "vely" : 0, "update" : function () {this.x += this.velx}, "radius" : 10, "color" : "orange"})}}},
        "CrabCakes" : { "name" : "CrabCakes", "score" : 700, "w" : 200, "h" : 200, "velx" : 20, "vely" : 4, "img" : "crabCakesA", "item" : "hellFire", "update" : function() {this.x -= this.velx; if (this.x < 0) this.velx = -this.velx; if (this.x + this.w > canvas.width && this.velx < 0) this.velx = -this.velx; this.y -= this.vely; if (this.y < 0) this.vely = -this.vely; if (this.y + this.h > canvas.height && this.vely < 0) this.vely = -this.vely;}}
    },
    "ItemData" : {
        "mega" : {"name" : "Mega", "img" : "orbmega", "color" : "green", "duration" : 1, "action" : function () {game.playerArray[0].changeMode('mega', this.duration, this.color, this.name);}},
        "dualLaser" : {"name" : "Dual Laser", "img" : "orblaser", "color" : "purple", "duration" : 2, "action" : function () {game.playerArray[0].changeWeapon("dualLaser", this.duration, this.color, this.name);}},
        "shockWave" : {"name" : "Shock Wave", "img" : "orbshock", "color" : "yellow", "duration" : 3, "action" : function () {game.playerArray[0].changeWeapon("shockWave", this.duration, this.color, this.name);}},
        "homingMissile" : {"name" : "Homing Missile", "img" : "orbhoming",  "color" : "red", "duration" : 4, "action" : function () {game.playerArray[0].changeWeapon("homingMissile", this.duration, this.color, this.name);}},
        "bouncyBalls" : {"name" : "Bouncy Balls", "img" : "orbbouncy",  "color" : "blue", "duration" : 5, "action" : function () {game.playerArray[0].changeWeapon("bouncyBalls", this.duration, this.color, this.name);}},
        "drill" : {"name" : "Drill", "img" : "orbdrill", "color" : "orange", "duration" : 6, "action" : function () {game.playerArray[0].changeMode('drill', this.duration, this.color, this.name);}},
        "hellFire" : {"name" : "Hell Fire", "img" : "orbhellfire", "color" : "black", "duration" : 7, "action" : function () {game.playerArray[0].changeWeapon("hellFire", this.duration, this.color, this.name);}}
    },
    "WeaponData" : {     // TODO: figure out whether to put this with itemData, not sure yet
        "peaShooter" : {"fire" : function() {game.playerProjectileArray[game.playerProjectileArray.length] = new sideScrollLevel.Blast({"name" : "Placebo", "velx" : 10, "vely" : 0, "radius" : 10, "color" : "white"})}},
        "dualLaser" : {"fire" : function() {game.playerProjectileArray[game.playerProjectileArray.length] = new sideScrollLevel.Blast({"name" : "Speed", "y" : (game.playerArray[0].y + game.playerArray[0].h/2)-15, "velx" : 10, "vely" : 0, "radius" : 7, "color" : "red"}); game.playerProjectileArray[game.playerProjectileArray.length] = new sideScrollLevel.Blast({"name" : "Speed", "y" : (game.playerArray[0].y + game.playerArray[0].h/2)+15, "velx" : 10, "vely" : 0, "radius" : 7, "color" : "red"});}},
        "shockWave" : {"fire" : function() {game.playerProjectileArray[game.playerProjectileArray.length] = new sideScrollLevel.Blast({"name" : "Molly", "velx" : 10, "vely" : 0, "update" : function () {this.x += this.velx; var sin = Math.sin(this.x * 2.5) * 8; this.y += sin;}, "radius" : 10, "color" : "yellow"})}},
        "homingMissile" : {"fire" : function() {game.playerProjectileArray[game.playerProjectileArray.length] = new sideScrollLevel.Blast({"name" : "Coke", "velx" : 5, "vely" : 0, "update" : function () { if (game.opponentArray.length > 0) {this.y += (game.opponentArray[game.opponentArray.length-1].y - this.y) * .05;} this.x += this.velx;}, "radius" : 20, "color" : "red"})}},
        "bouncyBalls" : {"fire" : function() { game.playerProjectileArray[game.playerProjectileArray.length] = new sideScrollLevel.Blast({"name" : "LSD", "velx" : 10, "vely" : Math.round(Math.random()*2 - 1) * 10, "update" : function () {this.x += this.velx; this.y += this.vely; if (this.y < 0) this.vely = -this.vely; if (this.y + this.radius > canvas.height) this.vely = -this.vely;}, "radius" : 10, "color" : "purple"})}},
        "hellFire" : {"fire" : function() {game.playerProjectileArray[game.playerProjectileArray.length] = new sideScrollLevel.Blast({"name" : "Party", "velx" : Math.round(Math.random()*20 - 10), "vely" : Math.round(Math.random()*20 - 10), "update" : function () {this.x += this.velx; if (this.x < 0) this.velx = -this.velx; if (this.x + this.radius > canvas.width && this.velx > 0) this.velx = -this.velx; this.y -= this.vely; if (this.y < 0) this.vely = -this.vely; if (this.y + this.radius > canvas.height && this.vely < 0) this.vely = -this.vely;}, "radius" : 10, "color" : "red"})}}
    },
    "DisplayData" : {
        // TODO: make the topBar object work, "game" was undefined.
   /*     "topBar" : {"level" : game.currentLevel, "score" : game.score, "time" : 30, "lives" : game.lives,
            "update" : function() {},
            "render" : function() {
                game.bufferCanvasCtx.font = "20pt Arial";
                game.bufferCanvasCtx.fillStyle = "white";
                var ymargin = 30;
                game.bufferCanvasCtx.fillText("Level: " + game.currentLevel, 20, ymargin);
                game.bufferCanvasCtx.fillText("Score: " + game.score, 300, ymargin);
                game.bufferCanvasCtx.fillText("Time: " + game.currentTime.substr(0,2), 500, ymargin);
                game.bufferCanvasCtx.fillText("Lives: " + game.lives, 800, ymargin);
            }
        } */
    }
}

    var game = new Game();
    game.loadImage();
</script>
</body>
</html>